### 期末总结

#### week01

数组、链表、跳表

```
熟悉了数组、链表、跳表的各项操作的时间复杂度
```

栈、队列、优先队列、双端队列

```
栈：先进后出
队列：先进先出
优先队列：插入O(1)，查找O(logn) 按照元素的优先级取出，底层实现的数据结构较为多样和复杂 heap、bst、treap
双端队列：两端可以进出的队列，插入、删除都是O(1)，查找是O(n)
```

#### week02

哈希表、映射、集合

```
哈希表，也称散列表，是通过把关键码值(key value)映射到表中的一个位置来访问记录，这种映射函数叫散列函数，存放记录的数组叫哈希表
查询、添加、删除时间复杂度均为O(1)，当出现链表的情况，时间复杂度会退化成O(n)
```

树、二叉树、二叉搜索树

```
LinkedList是特殊化的树
树是特殊化的图

二叉树遍历
	前序遍历 - pre order - 根左右
	中序遍历 - in order - 左根右
	后序遍历 - post order - 左右根
	
二叉搜索树
	是指一棵空树或者具有下列性质的二叉树：
		左子树上所有结点的值均小于它的根结点的值
		右子树上所有结点的值均大于它的根结点的值
		左右子树也分别是二叉搜索树（提现了重复性）
	二叉搜索树的中序遍历是升序排列
	查询、插入、删除的时间复杂度均为O(logN)
```

堆和二叉堆、图

```
Heap: 可以迅速找到一堆树中的最大或者最小值的数据结构
大顶堆/大根堆 -- 根节点最大的堆
	find-max: O(1)
	delete-max: O(logN)
	insert(create): O(logN) or O(1)
小顶堆/小根堆 -- 根节点最小的堆

二叉堆
	通过完全二叉树实现
		是一棵完全树
		树中任意节点的值总是>=其子节点的值
	一般通过“数组”实现
	假设第一个元素在数组中的索引为0的话，父节点和子节点位置关系如下：
		索引为i的左孩子的索引是(2*i+1)
		索引为i的右孩子的索引是(2*i+2)
		索引为i的父节点的索引是floor((i-1)/2)
	insert插入操作
		新元素一律先插入到堆的尾部
		依次向上调整整个堆的结构（一直到根即可）
	Delete Max 删除堆顶操作
		将堆尾元素替换到顶部（堆顶将被替换删除掉）
		依次从根部向下调整整个堆的结构（一直到堆尾即可）
	二叉堆是堆（优先队列priority_queue）的一种常见且简单的实现，但并不是最优的实现。

图的属性
	Graph(V, E)
	V - vertex: 点
		入度和出度
		点与点之间：连通与否
	E - edge: 边
		有向和无向（单行线）
		权重（边长）
```

#### week03

泛型递归、树的递归

```
//递归代码模板
public void recur(int level, int param) {
	//terminator 递归终止条件
	if (level > MAX_LEVEL) {
		//process result
		return;
	}
	//process current logic 处理当前层逻辑
	process(level, param);
	//drill down 下探到下一层
	recur(level : level + 1, newParam);
	//restore current status 清理当前层（恢复当前层的状态）
}
//三个思维要点
1、抵制人肉递归
2、找最近重复性
3、数学归纳法思维
```

分治、回溯

```
//分治
化解成若干个子问题进行解决，组合子结果返回，重点在于重复性

//回溯 （试错思想，分步尝试）
1、路径：也就是已经做出的选择。
2、选择列表：也就是你当前可以做的选择。
3、结束条件：也就是到达决策树底层，无法再做选择的条件
backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
        # 做选择
        将该选择从选择列表移除
        路径.add(选择)
        backtrack(路径, 选择列表)
        # 撤销选择
        路径.remove(选择)
        将该选择再加入选择列表
```

#### week04

深度优先搜索和广度优先搜索

```java
//DFS模板
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> allResults = new ArrayList<>();
    if(root==null){
        return allResults;
    }
    travel(root,0,allResults);
    return allResults;
}


private void travel(TreeNode root,int level,List<List<Integer>> results){
    if(results.size()==level){
        results.add(new ArrayList<>());
    }
    results.get(level).add(root.val);
    if(root.left!=null){
        travel(root.left,level+1,results);
    }
    if(root.right!=null){
        travel(root.right,level+1,results);
    }
}


//BFS模板
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}

public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> allResults = new ArrayList<>();
    if (root == null) {
        return allResults;
    }
    Queue<TreeNode> nodes = new LinkedList<>();
    nodes.add(root);
    while (!nodes.isEmpty()) {
        int size = nodes.size();
        List<Integer> results = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            TreeNode node = nodes.poll();
            results.add(node.val);
            if (node.left != null) {
                nodes.add(node.left);
            }
            if (node.right != null) {
                nodes.add(node.right);
            }
        }
        allResults.add(results);
    }
    return allResults;
}
```

贪心算法

```
贪心：当下做局部最优判断
回溯：能够回退
动态规划：最优判断 + 回退
```

二分查找

```
二分查找的前提：
1、目标函数单调性（单调递增或者递减）
2、存在上下界（bounded）
3、能够通过索引访问（index accessible）
```

#### week06

动态规划

```
分治 + 最优子结构
动态规划 和 递归或者分治 没有根本上的区别（关键看有无最优的子结构）
共性：找到重复子问题
差异性：最优子结构、中途可以淘汰次优解

关键点：
	1、最优子结构 opt[n] = best_of(opt[n - 1] + opt[n - 2],...);
	2、储存中间状态：opt[i]
	3、递推公式 == 状态转移方程 == DP方程
		Fib:opt[i] = opt[i - 1] + opt[i - 2];
		二维路径：opt[i,j] = opt[i+1][j] + opt[i][j+1], (且判断a[i,j]是否为空地)
	1、重复子问题
	2、状态定义数组
	3、DP方程
小结：
	1、打破自己的思维惯性，形成机器思维
	2、理解复杂逻辑的关键
	3、也是职业进阶的要点要领
```

#### week07

字典树和并查集

```
字典树
Trie树又称单词查找树或者键树，是一种树形结构。用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。
优点：最大限度的减少无谓的字符串比较，查询效率比哈希表高
基本性质：
	1、结点本身不存完整单词
	2、从根节点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串
	3、每个结点的所有子结点路径代表的字符都不相同
核心思想：
	空间换时间
	利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的

并查集
适用于组团、配对的问题

基本操作：
	makeSet(s)：建立一个新的并查集，其中包含s个单元素集合
	unionSet(x,y)：把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并
	find(x)：找到元素x所在的集合的代表，该操作也用于判断两个元素是否位于同一个集合，只要将他们各自的代表比较一下就可以了

初始化：parent[i] = i;

要熟悉什么类型的问题需要使用并查集解决
```

高级搜索

```
剪枝：在进行状态树搜索时，如果发现这个分支是已经处理过的，就把它暂存在缓存里面，整个分支就可以剪掉。 或者可以剪掉比较差的分支或次优的分支。

两端同时进行BFS，第一次重合的地方即为两者之间最短路径，左边步数加上右边步数即为总步数

启发式搜索
A*
估价函数：
启发式函数： h(n)，它用来评价哪些结点最有希望是一个我们要找的结点，h(n) 会返回一个非负实数,也可以认为是从结点n的目标结点路径的估计成本。

启发式函数是一种告知搜索方向的方法。它提供了一种明智的方法来猜测哪个邻居结点会导向一个目标
```

红黑树和AVL树

```
AVL树
平衡二叉搜索树；
Balance Factor（平衡因子）： 是它的左子树的高度减去它的右子树的高度（有时相反）。 balance factor = {-1, 0, 1}；
通过旋转操作来进行平衡（四种）：左旋（右右子树）、右旋（左左子树）、左右旋（左右子树）、右左旋（右左子树）。
不足：结点需要存储额外信息、且调整次数频繁。

左旋就是左面的结点下去，同理右旋

红黑树
红黑树是一种近似平衡的二叉搜索树（BinarySearch Tree），它能够确保任何一个结点的左右子树的高度差小于两倍。 具体来说，红黑树是满足如下条件的二叉搜索树：

每个结点要么是红色，要么是黑色；
根结点是黑色；
每个叶结点（NIL结点，空结点）是黑色的；
不能有相邻接的两个红色结点；
从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。
关键性质：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。
```

#### week08

位运算

```
位运算符
	左移 <<
	右移 >>
	按位或 | 只要两个中有1，运算结果就为1
	按位与 & 只要两个中有0，运算结果就为0
	按位取反 ~ 0 --> 1  1 --> 0
	按位异或 ^ 相同为0，不同为1，可以理解为不进位加法
	
指定位置的位运算
	将x最右边的n位清零：x&(~0<<n)
	获取x的第n位值（0或者1）：(x>>n)&1
	获取x的第n位的幂值：x&(1<<n)
	仅将第n位置为1：x|(1<<n)
	仅将第n位置为0：x&(~(1<<n))
	将x最高位至第n位（含）清零：x&((1<<n)-1)
	将第n位至第0位（含）清零：x&(~((1<<(n+1))-1))
	
实战位运算要点
	判断奇偶
		x%2==1 --> (x&1)==1
		x%2==0 --> (x&1)==0
	x>>1 --> x/2
	X = X & (X - 1) 清零最低位的1
	X & -X 得到最低位的1
	X & ~X 0
```

布隆过滤器和LRU cache

```
BloomFilter
一个很长的二进制向量和一系列随机映射函数。
布隆过滤器可以用于检索一个元素是否在一个集合中。

优点是空间效率和查询时间都远远超过一般的算法
缺点是有一定的误识别率和删除困难

元素去布隆过滤器中查，如果查到不在，那肯定不存在；如果查得到，则可能存在也可能不存在。

案例：
	比特币网络
	分布式系统（Map-Reduce）-- Hadoop、search engine
	Redis缓存
	垃圾邮件、评论等的过滤

LRU cache
两个要素：大小、替换策略
HashTable + Double LinkedList

O(1)查询
O(1)修改、更新

替换策略
	LFU -- least frequently used
	LRU -- least recently used
```

排序算法

```
排序算法
	比较类排序
		通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
	非比较类排序
		不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序
初级排序 -- O(n^2)
	选择排序（Selection Sort）
		每次找到最小值，然后放到待排序数组的起始位置
	插入排序（Insertion Sort）
		从前到后逐步构建有序序列；对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入
	冒泡排序（Bubble Sort）
		嵌套循环，每次查看相邻的元素，如果逆序，则交换
高级排序 -- O(n*logn)
	快速排序（Quick Sort）
		数组取标杆pivot，将小元素放在pivot左边，大元素放右侧，然后依次对右边和右边的子数组继续快排，以达到整个序列有序
	归并排序（Merge Sort）-- 分治
    	把长度为n的输入序列分成两个长度为n/2的子序列
    	对这两个子序列分别采用归并排序
    	将两个排序好的子序列合并成一个最终的排序序列
    *快排和归并 具有相似性，但步骤顺序相反
    *归并：先排序左右子数组，然后合并两个左右子数组
    *快排：先调配出左右子数组，然后对于左右子数组进行排序
    堆排序（Heap Sort）-- 堆插入O(logN)，取最大/小值O(1)
    	数组元素依次建立小顶堆
    	依次取堆顶元素，并删除
特殊排序 -- O(n)
	计数排序（Counting Sort）
		计数排序要求输入的数据必须是有确定范围的整数，将输入的数据值转化为键存储在额外开辟的数组空间中，然后依次把计数大于1的填充回原数组
	桶排序（Bucket Sort）
		假设输入数据服从均匀分步，将数据分到有限数量的桶里，每个桶在分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）
	基数排序（Radix Sort）
		按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，知道最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。
```

#### week09

高级动态规划

```
状态拥有更多维度（二维、三维或者更多，甚至需要压缩）
状态方程更加复杂
```

字符串算法



#### 总结

通过算法训练营为期70天的学习+刻意练习，不仅使我在算法知识层面得到了更深入的学习，更重要的是学到了超哥的五毒神掌这一神迹，虽然由于个人在工作、学习和生活的时间分配不合理导致没有办法完美运用五毒神掌，但是我明白，70天之后的自我修炼才是真正挑战的开始，希望自己可以不忘初心，继续前行。